Регулярные выражения
########################################################################################################################

Создание регулярных выражений:
1) создание с помощью конструктора RegExp:
let re1 = new RegExp("abc");
2) с помощью литерального значения, в которо заключен шаблон между символами косой черты:
let re2 = /abc/;

Проверка на соответствия:
У объектов регулярных выражений есть несколько методов. Самый простой из них - test. Если передать ему строку,
то он вернет логическое значение, сообщающее, содержит ли данная строка шаблон, указанный в выражении.
console.log(/abc/.test("abcde"));
// → true
console.log(/abc/.test("abxde"));
// → false

Если в регулярном выражении разместить несколько символов в квадратных скобках, то данная часть выражения будет
соответствовать любому из символов, находящихся в квадратных скобках. Оба следующих выражения соответствуют
всем строкам, которые содержат цифры:
console.log(/[0123456789]/.test("in 1992"));
// → true
console.log(/[0-9]/.test("in 1992"));
// → true

Тире (-) между двумя символами, заключенными в квадратные скобки, может использоваться для обозначения диапазона
символов, порядок следования которых определяется номером символа в кодировке Unicode.

Некоторые стандартные группы символов имеют собственные встроенные комбинации. Цифры являются одной из них:
\d означает то же самое, что и [0-9):
\d - любая цифра;
\w - любой алфавитно-цифровой символ (словообразующий символ);
\s - любой пробельный символ (пробел, табуляция, новая строка и т. п.);
\D - символ, который не является цифрой;
\W - не алфавитно-цифровой символ;
\S - не пробельный символ;
, - любой символ, кроме новой строки.

Эти коды с обратной косой чертой также могут использоваться в квадратных скобках. Например, [ \d. ]
означает любую цифру или символ точки. Но сама точка, заключенная в квадратные скобки, теряет свое особое значение.
То же касается других специальных символов, таких как +.

Чтобы инвертировать набор символов, то есть сказать, что вы хотите получить любой символ, кроме символов,
входящих в данное множество, можно поставить после открывающей скобки символ вставки (^).
let notBinary = /[^01]/;
console.log(notBinary.test("1100100010100110"));
// → false
console.log(notBinary.test("1100100010200110"));
// → true

Повторяющиеся части шаблона
Теперь мы знаем, как обозначить в шаблоне одну любую цифру. А что, если мы хотим обозначить целое число -
последовательность из одной или нескольких цифр?
Если после чего-либо в регулярном выражении поставить знак "плюс" ( + ), это будет означать, что данный элемент
может повторяться несколько раз. Так, /\d+/ соответствует одной или нескольким цифрам.
console.log(/'\d+'/.test("'123'"));
// → true
console.log(/'\d+'/.test("''"));
// → false
console.log(/'\d*'/.test("'123'"));
// → true
console.log(/'\d*'/.test("''"));
// → true

Звездочка(*) имеет аналогичное значение, но шаблон с ее использованием соответствует также нулю повторений.
Если после чего-то стоит звездочка, данная часть шаблона не мешает соответствию - если не будет найден подходящий
текст, то шаблон просто посчитает это нулевым количеством найденных соответствий.

Вопросительный знак делает часть шаблона необязательной, то есть она может встретиться один раз
или не встретиться ни разу. В следующем примере допускается наличие символа u, но если его не будет,
шаблон все равно считается соответствующим.
let neighbor = /neighbou?r/;
console.log(neighbor.test("neighbour"));
// → true
console.log(neighbor.test("neighbor"));
// → true

Чтобы показать, что фрагмент должен встречаться точное количество раз, применяются фигурные скобки.
Например, если после элемента поставить {4}, то этот элемент должен повториться именно четыре раза.
Можно также указать диапазон: {2,4} означает, что элемент должен повториться минимум дважды и максимум четыре раза.
let dateTime = /\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/;
console.log(dateTime.test("1-30-2003 8:45"));
// → true

Группировка подвыражений
Чтобы использовать операторы типа* или+ для нескольких повторений элемента, нужно задействовать скобки.
Часть регулярного выражения, заключенная в круглые скобки, считается одним элементом по отношению
к следующим за ней операторам.
Первый и второй знаки «плюс» применяются только ко второй букве о во фрагменгах Ьоо и hoo соответственно.
Третий плюс применяется ко всей группе (hoo+ ), так что ей соответствует одна или несколько таких последовательностей.
Буква i в конце выражения в данном примере делает это регулярное выражение нечувствительным к регистру,
так что ему подходит прописная буква в во входной строке, даже если сам шаблон написан строчными буквами.
let cartoonCrying = /boo+(hoo+)+/i;
console.log(cartoonCrying.test("Boohoooohoohooo"));
// → true

Соответствия и группы
Метод test - это простейший способ проверить соответствие регулярного выражения. Данный метод сообщает нам только о том,
обнаружено ли соответствие, и ничего больше. Для регулярных выражений также существует метод ехес (от слова execute -
«выполнить~), который возвращает null, если совпадение не найдено, и объект с информацией о совпадении в противном случае.

let match = /\d+/.exec("one two 100");
console.log(match);
// → ["100"]
console.log(match.index);
// → 8

Объект, который возвращает метод ехес, имеет свойство index, сообщающее нам, где именно в строке найдено совпадение
с шаблоном. Кроме этого, объект выглядит как массив строк (и фактически им является), первый элемент которого - строка,
соответствующая шаблону. В предыдущем примере это искомая последовательность цифр.

Для строковых значений существует метод match, который ведет себя аналогичным образом.
console.log("one two 100".match(/\d+/));
// → ["100"]

Если регулярное выражение содержит подвыражения, заключенные в скобки, то текст, соответствующий этим группам,
также будет представлен в массиве. Первым элементом массива всегда является полное совпадение. Следующий элемент
- та часть, которая соответствует первой группе (открывающая скобка которой стоит первой в выражении),
затем идет соответствие второй группе и т. д.
let quotedText = /'([^']*)'/;
console.log(quotedText.exec("she said 'hello'"));
// → ["'hello'", "hello"]

Класс Date
console.log(new Date());
// 4 Mon Nov 13 2017 16:19:11 GMT+0100 (СЕТ)

Можно также создать объект для определенного времени.
console.log(new Date(2009, 11, 9));
// → Wed Dec 09 2009 00:00:00 GMT+0100 (CET)
console.log(new Date(2009, 11, 9, 12, 59, 59, 999));
// → Wed Dec 09 2009 12:59:59 GMT+0100 (CET)

В JavaScript используется соглашение, согласно которому номера месяцев начинаются с нуля (поэтому декабрь имеет номер
11), а номера дней - с единицы. Это сбивает с толку и вообще глупо. Последние четыре аргумента (часы, минуты, секунды
и миллисекунды) являются необязательными, и если не заданы, то считаются равными нулю.

Метки времени хранятся в виде количества миллисекунд с начала да в часовом поясе UTC - 1970 гов соответствии
с заключенным в то время соглашением о Uniх-времени. Для описания времени до 1970 года можно использовать отрицательные
числа. Такое число возвращает метод getTime объекта даты. Как нетрудно догадаться, это большое число.

Если передать конструктору Date только один аргумент, он будет считаться временем в миллисекундах. Чтобы получить
текущее значение времени в миллисекундах, нужно создать новый объект getтime либо вызвать функцию Date и вызвать
для него Date.now.

Для извлечения компонентов даты объекты Date имеют такие методы, как getFullYear, getMonth, getDate, getHours,
getMinutes и getSeconds. Помимо getFullYear, также есть метод getYear, который возвращает год минус 1900 (98 или 119)
и, как правило, бесполезен.

Заключив интересующие нас части выражения в скобки, мы теперь можем создать объект даты из строки. Привязка _
(подчеркивание) игнорируется и используется только для того, чтобы пропустить элемент полного совпадения в массиве,
возвращаемом методом ехес.
function getDate(string) {
  let [_, month, day, year] =
    /(\d{1,2})-(\d{1,2})-(\d{4})/.exec(string);
  return new Date(year, month - 1, day);
}
console.log(getDate("1-30-2003"));
// → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)

Границы слов и строк
Для того чтобы принудительно потребовать совпадения всей строки, можно добавить маркеры ^ и $.
Символ ^ соответствует началу входной строки, а знак доллара $ - ее концу. Таким образом, /^\d+$/ означает строку,
полностью состоящую из одной или нескольких цифр; /^!/ соответствует любой строке, которая начинается с восклицательного
знака, а /х^/ не соответствует ни одной строке (х не может стоять перед началом строки).
Если же мы лишь хотим гарантировать, что дата начинается и заканчивается на границе слова, то можно использовать
маркер \Ь. Граница слова может быть началом или концом строки или находиться в любой другой точке строки, у которой
с одной стороны стоит словообразующий символ (как в \w), а с другой - несловообразующий символ.

Выбор шаблонов
Мы могли бы написать три регулярных выражения и проверить их все по очереди, но есть способ получше. Символ вертикальной
черты (|) обозначает выбор между шаблонами, расположенными слева и справа от него. Так что можно написать так:
let animalCount = /\b\d+ (pig|cow|chicken)s?\b/;
console.log(animalCount.test("15 pigs"));
// → true
console.log(animalCount.test("15 pigchickens"));
// → false

Чтобы ограничить часть шаблона, к которой должен применяться оператор |, можно заключить ее в скобки;
для описания выбора из более чем двух альтернатив можно использовать несколько таких операторов последовательно.

Метод replace

