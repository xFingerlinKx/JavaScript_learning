Автоматическое преобразование типов
########################################################################################################################

JavaScript совершает все возможное, чтобы выполнить практически любую программу, которую вы ему предлагаете,
даже если эта программа делает странные вещи.

console.log(8 * null)
// → 0
console.log("5" - 1)
// → 4
console.log("5" + 1)
// → 51
console.log("five" * 2)
// → NaN
console.log(false == 0)
// → true

Когда оператор применяется к 0 "неправильному" типу значения,JаvаSсгiрt незаметно для вас преобразует это значение
в нужный тип, используя набор правил, которые часто не соответствуют вашим желаниям или ожиданиям.
Это называется приведением типов.
null в первом выражении заменяется на 0, а "5" во втором выражении превращается в 5 (строка становится числом).
Однако в третьем выражении оператор + пытается сначала выполнить конкатенацию строк, а затем сложение чисел,
поэтому 1 преобразуется в "1" (число - в строку).

Когда что-то, что нельзя преобразовать в число очевидным способом (например, "пять" или undefined),
все же преобразуется в число, получается значение NaN. Результатом последующих арифметических операций с NaN будет NaN.
Поэтому, если вы обнаружите данное значение там, где его не должно быть, ищите случайные преобразования типов.

При сравнении значений одного и того же типа с использованием оператора == результат легко предсказуем:
это должно быть true, когда значения одинаковы, если только они не равны NaN.
Но если типы различаются, то JavaScгipt задействует сложный и запутанный набор правил, чтобы определить, что делать.
В большинстве случаев он просто пытается преобразовать одно из значений в тип другого. Но если с любой стороны от оператора
появляется null или undefined, то результатом будет true, только если обе стороны равны null или же обе равны undefined.

console.log(null == undefined);
// → true
console.log(null == 0);
// → false

Такое поведение часто бывает полезным. Если вы хотите проверить, это определенное значение или же null или undefined,
то можете сравнить его с помощью оператора == (или ! = ).
Но как быть, если вы хотите убедиться, что какое-либо значение точно равно false? Выражения типа 0 == false и "" == false
являются истинными вследствие автоматического преобразования типов. На тот случай, если вы не хотите, чтобы выполнялись
какие-либо преобразования типов, есть два дополнительных оператора:
=== и !==.
Первый из них проверяет, точно ли значение равно другому, а второй - точно ли оно не равно. Таким образом, "" === false
будет ложным, как и ожидалось. В целях защиты от неожиданных преобразований типов я рекомендую использовать
трехсимвольные операторы сравнения. Но если вы уверены, что типы с обеих сторон будут одинаковыми, то проблем
с применением более коротких операторов не возникнет.