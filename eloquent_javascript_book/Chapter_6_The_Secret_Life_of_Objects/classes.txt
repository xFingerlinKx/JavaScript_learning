Классы
########################################################################################################################

Система прототипов JavaScript может быть интерпретирована как несколько неформальная реализация объектно-ориентированной
концепции, называемой классами. Класс - вариант типа объекта, описывающий, какие методы и свойства имеет данный объект.
Такой объект называется экземпляром класса. Прототипы полезны для определения свойств, имеющих одинаковое значение для
всех экземпляров класса, таких как методы. Свойства, которые отличаются в каждом конкретном случае, такие как свойство
type для наших кроликов, должны храниться непосредственно в самих объектах.

Таким образом, чтобы создать экземпляр данного класса, нужно создать объект, производный от выбранного прототипа, но,
кроме того, следует убедиться, что сам этот объект обладает свойствами, которые должны иметь экземпляры данного класса.
Для этого используется функция конструктора.

let protoRabbit = {
  speak(line) {
    console.log(`The ${this.type} rabbit says '${line}'`);
  }
};

function makeRabbit(type) {
  let rabbit = Object.create(protoRabbit);
  rabbit.type = type;
  return rabbit;
}

JavaScript позволяет упростить определение функций этого типа. Если поставить перед вызовом функции ключевое слово new,
то функция будет считаться конструктором. Это означает, что в ней будет автоматически создан объект с выбранным прототипом,
он будет привязан к this и возвращен в конце выполнения функции. Объект-прототип, используемый при построении объектов,
определяется путем получения свойства prototype функции-конструктора.

function Rabbit(type) {
  this.type = type;
}
Rabbit.prototype.speak = function(line) {
  console.log(`The ${this.type} rabbit says '${line}'`);
};

let weirdRabbit = new Rabbit("weird");

Конструкторы (в сущности, как и остальные функции) автоматически получают свойство с именем prototype, которое по
умолчанию содержит просто пустой объект, производный от Object.prototype. При желании его можно перезаписать новым
объектом. Или же добавить свойства к существующему объекту, как в данном примере. По соглашению имена конструкторов
пишутся с большой буквы, чтобы легко отличать их от других функций.

Важно понимать различие между тем как прототип связан с конструктором (через свойство prototype), и тем, что у объектов
есть прототип (который можно узнать с помощью Object.getPrototypeOf).

Настоящим прототипом конструктора выступает Function.prototype, поскольку конструкторы являются функциями. Его свойство
prototype содержит прототип, используемый для создаваемых с его помощью экземпляров.

console.log(Object.getPrototypeOf(Rabbit) == Function.prototype);
// → true
console.log(Object.getPrototypeOf(weirdRabbit) == Rabbit.prototype);
// → true

Запись классов
--------------
Таким образом, классы в javaScript - это функции-конструкторы со свойством прототипа. Так они работают, и именно так до
2015 года их следовало писать. В наши дни появилась менее неуклюжая запись.

class Rabbit {
  constructor(type) {
    this.type = type;
  }
  speak(line) {
    console.log(`The ${this.type} rabbit says '${line}'`);
  }
}

let killerRabbit = new Rabbit("killer");
let blackRabbit = new Rabbit("black");

Ключевое слово class означает начало описания класса. В этом описании содержатся определение конструктора и набор методов
- все в одном месте. В скобках описания класса может содержаться любое количество методов. Один из таких методов, с именем
constructor, имеет специальное назначение. Он представляет собой функцию конструктора, которая будет связана с именем Rabbit.
Остальные методы будут упакованы в прототип данного конструктора. Таким образом, это определение класса эквивалентно
определению конструктора из предыдущего раздела, но выглядит лучше. В настоящее время определения классов позволяют создавать
в прототипе только методы - свойства, которые содержат функции. Это бывает не очень удобно, если нужно сохранить в классе
нефункциональные значения. Вероятно, в следующей версии языка это будет улучшено. Пока что мы можем создавать такие свойства,
непосредственно управляя прототипом после того, как определили класс.

Подобно ключевому слову function, ключевое слово class может применяться как в инструкциях, так и в выражениях.
При использовании в качестве выражения оно не определяет привязку, а лишь создает конструктор как значение.
В выражении класса имя класса разрешается опустить.

let object = new class { getWord() { return "hello"; } };
console.log(object.getWord());
// → hello

Переопределение производных свойств
-----------------------------------
Когда вы добавляете свойство к объекту, независимо от того, присутствует оно в прототипе или нет, свойство добавляется
к самому объекту. Если в прототипе уже было свойство с таким именем, оно больше не будет влиять на объект, будучи
скрыто за собственным свойством объекта.

Rabbit.prototype.teeth = "small";
console.log(killerRabbit.teeth);
// → small
killerRabbit.teeth = "long, sharp, and bloody";
console.log(killerRabbit.teeth);
// → long, sharp, and bloody
console.log(blackRabbit.teeth);
// → small
console.log(Rabbit.prototype.teeth);
// → small

Переопределение также применяется для того, чтобы придать стандартным прототипам функции и массива новый метод toString,
отличный от прототипа базового объекта.

console.log(Array.prototype.toString == Object.prototype.toString);
// → false
console.log([1, 2].toString());
// → 1,2