Наследование
########################################################################################################################

class SymmetricMatrix extends Matrix {
  constructor(size, element = (x, y) => undefined) {
    super(size, size, (x, y) => {
      if (x < y) return element(y, x);
      else return element(x, y);
    });
  }

  set(x, y, value) {
    super.set(x, y, value);
    if (x != y) {
      super.set(y, x, value);
    }
  }
}

let matrix = new SymmetricMatrix(5, (x, y) => `${x},${y}`);
console.log(matrix.get(2, 3));
// → 3,2

Слово extends указывает на то, что данный класс основан не на прототипе Object, как принято по умолчанию, а на каком-то
другом классе, который называется суперклассом. Производный класс является подклассом.

Наследование позволяет создавать типы данных, слегка отличающиеся от уже существующих, с относительно небольшими затратами.
Это фундаментальная часть объектно-ориентированной традиции наряду с инкапсуляцией и полиморфизмом. Но если последние две
концепции в настоящее время принято считать прекрасными идеями, наследование вызывает больше споров. Если инкапсуляция и
полиморфизм применяются для того, чтобы отделить части кода друг от друга, делая программу в целом менее запутанной, то
наследование фундаментально связывает классы вместе, создавая больше путаницы. При наследовании от класса обычно
необходимо знать о том, как он работает, больше, чем при простом использовании.

Иногда полезно знать, является ли объект производным от определенного класса. Для этого вJavaScript существует
бинарный оператор instanceof.